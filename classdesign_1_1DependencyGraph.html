<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RNAblueprint-1.3.2: design::DependencyGraph&lt; R &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rnablueprint-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RNAblueprint-1.3.2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdesign_1_1DependencyGraph.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">design::DependencyGraph&lt; R &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Dependency Graph which holds all structural constraints.  
 <a href="classdesign_1_1DependencyGraph.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af293de4060b1fb0b36a2a6fa2e0688cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#af293de4060b1fb0b36a2a6fa2e0688cc">DependencyGraph</a> (std::vector&lt; std::string &gt; structures, std::string constraints, R rand)</td></tr>
<tr class="memdesc:af293de4060b1fb0b36a2a6fa2e0688cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the Dependency graph.  <a href="classdesign_1_1DependencyGraph.html#af293de4060b1fb0b36a2a6fa2e0688cc">More...</a><br /></td></tr>
<tr class="separator:af293de4060b1fb0b36a2a6fa2e0688cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250d599c82d2b41260583dd2d6a8fdf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a250d599c82d2b41260583dd2d6a8fdf3">DependencyGraph</a> (std::vector&lt; std::string &gt; structures, std::string constraints, unsigned long seed)</td></tr>
<tr class="memdesc:a250d599c82d2b41260583dd2d6a8fdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for the Dependency graph using a predefined random number generator with the given seed.  <a href="classdesign_1_1DependencyGraph.html#a250d599c82d2b41260583dd2d6a8fdf3">More...</a><br /></td></tr>
<tr class="separator:a250d599c82d2b41260583dd2d6a8fdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ee356ef0a9640cd3087818e5c28d16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#aa8ee356ef0a9640cd3087818e5c28d16">DependencyGraph</a> (std::vector&lt; std::string &gt; structures, std::string constraints)</td></tr>
<tr class="memdesc:aa8ee356ef0a9640cd3087818e5c28d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for the Dependency graph using a predefined random number generator with a clock generated seed.  <a href="classdesign_1_1DependencyGraph.html#aa8ee356ef0a9640cd3087818e5c28d16">More...</a><br /></td></tr>
<tr class="separator:aa8ee356ef0a9640cd3087818e5c28d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6ca86ea783a2b6311f391cfd193ad1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#afa6ca86ea783a2b6311f391cfd193ad1">DependencyGraph</a> (std::vector&lt; std::string &gt; structures, R rand)</td></tr>
<tr class="memdesc:afa6ca86ea783a2b6311f391cfd193ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for the Dependency graph without any sequence constraints.  <a href="classdesign_1_1DependencyGraph.html#afa6ca86ea783a2b6311f391cfd193ad1">More...</a><br /></td></tr>
<tr class="separator:afa6ca86ea783a2b6311f391cfd193ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f7113163d68de94cb8a3481c87d392"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a37f7113163d68de94cb8a3481c87d392">DependencyGraph</a> (std::vector&lt; std::string &gt; structures)</td></tr>
<tr class="memdesc:a37f7113163d68de94cb8a3481c87d392"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for the Dependency graph using a predefined random number generator with a clock generated seed and an empty string as sequence constraints.  <a href="classdesign_1_1DependencyGraph.html#a37f7113163d68de94cb8a3481c87d392">More...</a><br /></td></tr>
<tr class="separator:a37f7113163d68de94cb8a3481c87d392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4fad246b5719f03f2428946c8423db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a7b4fad246b5719f03f2428946c8423db">DependencyGraph</a> (const <a class="el" href="classdesign_1_1DependencyGraph.html">DependencyGraph</a> &amp;copy)</td></tr>
<tr class="memdesc:a7b4fad246b5719f03f2428946c8423db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor which sets a new random seed in the copy sampled from the old generator.  <a href="classdesign_1_1DependencyGraph.html#a7b4fad246b5719f03f2428946c8423db">More...</a><br /></td></tr>
<tr class="separator:a7b4fad246b5719f03f2428946c8423db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550da1f6eebbe7881de860fc6dc76035"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a550da1f6eebbe7881de860fc6dc76035">~DependencyGraph</a> ()</td></tr>
<tr class="memdesc:a550da1f6eebbe7881de860fc6dc76035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for the dependency graph object.  <a href="classdesign_1_1DependencyGraph.html#a550da1f6eebbe7881de860fc6dc76035">More...</a><br /></td></tr>
<tr class="separator:a550da1f6eebbe7881de860fc6dc76035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911ddbc7d43c66a43c145dee29ca6c20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a911ddbc7d43c66a43c145dee29ca6c20">set_history_size</a> (unsigned int size)</td></tr>
<tr class="memdesc:a911ddbc7d43c66a43c145dee29ca6c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of previous sampled sequences to memorize (Default: 100).  <a href="classdesign_1_1DependencyGraph.html#a911ddbc7d43c66a43c145dee29ca6c20">More...</a><br /></td></tr>
<tr class="separator:a911ddbc7d43c66a43c145dee29ca6c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a3410de661dd384b7d170e5108ed0c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#ac0a3410de661dd384b7d170e5108ed0c">get_graphml</a> ()</td></tr>
<tr class="memdesc:ac0a3410de661dd384b7d170e5108ed0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the root graph in GraphML format as a string.  <a href="classdesign_1_1DependencyGraph.html#ac0a3410de661dd384b7d170e5108ed0c">More...</a><br /></td></tr>
<tr class="separator:ac0a3410de661dd384b7d170e5108ed0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63f04ba5a78ad4199766966896e138f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#ad63f04ba5a78ad4199766966896e138f">get_graphml</a> (int connected_component_ID)</td></tr>
<tr class="memdesc:ad63f04ba5a78ad4199766966896e138f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connected component graph with the connected_component_ID in GraphML format as a string.  <a href="classdesign_1_1DependencyGraph.html#ad63f04ba5a78ad4199766966896e138f">More...</a><br /></td></tr>
<tr class="separator:ad63f04ba5a78ad4199766966896e138f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214f172251f252e0b422e858f0ef1a38"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a214f172251f252e0b422e858f0ef1a38">get_sequence</a> ()</td></tr>
<tr class="memdesc:a214f172251f252e0b422e858f0ef1a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current RNA sequence as a string.  <a href="classdesign_1_1DependencyGraph.html#a214f172251f252e0b422e858f0ef1a38">More...</a><br /></td></tr>
<tr class="separator:a214f172251f252e0b422e858f0ef1a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdf0881f3bfaac53bdc8c0752d7b9f2"><td class="memItemLeft" align="right" valign="top">SolutionSizeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a0fdf0881f3bfaac53bdc8c0752d7b9f2">set_sequence</a> (std::string sequence)</td></tr>
<tr class="memdesc:a0fdf0881f3bfaac53bdc8c0752d7b9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to set a initial sequence as starting point for your optimization.  <a href="classdesign_1_1DependencyGraph.html#a0fdf0881f3bfaac53bdc8c0752d7b9f2">More...</a><br /></td></tr>
<tr class="separator:a0fdf0881f3bfaac53bdc8c0752d7b9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5c3c400f0008e440e49afa7da36567"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#aca5c3c400f0008e440e49afa7da36567">revert_sequence</a> ()</td></tr>
<tr class="memdesc:aca5c3c400f0008e440e49afa7da36567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverts the sequence to the previous one.  <a href="classdesign_1_1DependencyGraph.html#aca5c3c400f0008e440e49afa7da36567">More...</a><br /></td></tr>
<tr class="separator:aca5c3c400f0008e440e49afa7da36567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad199db489d2b88692f59e0eadfec74ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#ad199db489d2b88692f59e0eadfec74ee">revert_sequence</a> (unsigned int jump)</td></tr>
<tr class="memdesc:ad199db489d2b88692f59e0eadfec74ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverts the sequence to a previous one being (jump) steps in the history;.  <a href="classdesign_1_1DependencyGraph.html#ad199db489d2b88692f59e0eadfec74ee">More...</a><br /></td></tr>
<tr class="separator:ad199db489d2b88692f59e0eadfec74ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce7a6cc23ec087466079e4967d4380f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a8ce7a6cc23ec087466079e4967d4380f">get_history</a> ()</td></tr>
<tr class="memdesc:a8ce7a6cc23ec087466079e4967d4380f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the history of previous sampled sequences at this point.  <a href="classdesign_1_1DependencyGraph.html#a8ce7a6cc23ec087466079e4967d4380f">More...</a><br /></td></tr>
<tr class="separator:a8ce7a6cc23ec087466079e4967d4380f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535101494526f22fdc7f049144fe962e"><td class="memItemLeft" align="right" valign="top">SolutionSizeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a535101494526f22fdc7f049144fe962e">sample</a> ()</td></tr>
<tr class="memdesc:a535101494526f22fdc7f049144fe962e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all bases in the whole dependency graph and samples a new sequence randomly.  <a href="classdesign_1_1DependencyGraph.html#a535101494526f22fdc7f049144fe962e">More...</a><br /></td></tr>
<tr class="separator:a535101494526f22fdc7f049144fe962e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8203aff1c75840df6ccabb1e08d4c8"><td class="memItemLeft" align="right" valign="top">SolutionSizeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a4f8203aff1c75840df6ccabb1e08d4c8">sample</a> (int position)</td></tr>
<tr class="memdesc:a4f8203aff1c75840df6ccabb1e08d4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets and samples only the smallest subgraph(s) possible containing the vertex at the given position in the sequence.  <a href="classdesign_1_1DependencyGraph.html#a4f8203aff1c75840df6ccabb1e08d4c8">More...</a><br /></td></tr>
<tr class="separator:a4f8203aff1c75840df6ccabb1e08d4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd1274742cce748ff01abcf96d9b8e4"><td class="memItemLeft" align="right" valign="top">SolutionSizeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a0fd1274742cce748ff01abcf96d9b8e4">sample</a> (int start, int end)</td></tr>
<tr class="memdesc:a0fd1274742cce748ff01abcf96d9b8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets only the smallest subgraph(s) possible containing the vertices from position start to end.  <a href="classdesign_1_1DependencyGraph.html#a0fd1274742cce748ff01abcf96d9b8e4">More...</a><br /></td></tr>
<tr class="separator:a0fd1274742cce748ff01abcf96d9b8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa17cde3896055c4e162a2e0864a11f2"><td class="memItemLeft" align="right" valign="top">SolutionSizeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#afa17cde3896055c4e162a2e0864a11f2">sample_plocal</a> (int min_num_pos, int max_num_pos)</td></tr>
<tr class="memdesc:afa17cde3896055c4e162a2e0864a11f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly chooses one path (either top-level a connected component, or within a block, etc.) with the given size and samples all positions.  <a href="classdesign_1_1DependencyGraph.html#afa17cde3896055c4e162a2e0864a11f2">More...</a><br /></td></tr>
<tr class="separator:afa17cde3896055c4e162a2e0864a11f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae147bb714306f05740a54d9970615ffa"><td class="memItemLeft" align="right" valign="top">SolutionSizeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#ae147bb714306f05740a54d9970615ffa">sample_plocal</a> ()</td></tr>
<tr class="memdesc:ae147bb714306f05740a54d9970615ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly chooses one path (either top-level a connected component, or within a block, etc.) and samples all positions.  <a href="classdesign_1_1DependencyGraph.html#ae147bb714306f05740a54d9970615ffa">More...</a><br /></td></tr>
<tr class="separator:ae147bb714306f05740a54d9970615ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c6f862884b192aec61394826359162"><td class="memItemLeft" align="right" valign="top">SolutionSizeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a25c6f862884b192aec61394826359162">sample_clocal</a> (int min_num_pos, int max_num_pos)</td></tr>
<tr class="memdesc:a25c6f862884b192aec61394826359162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly chooses a connected component with the given size and samples a new sequence for the whole component.  <a href="classdesign_1_1DependencyGraph.html#a25c6f862884b192aec61394826359162">More...</a><br /></td></tr>
<tr class="separator:a25c6f862884b192aec61394826359162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f9ae2e41909ab0aeb8ccabf99dc8ca"><td class="memItemLeft" align="right" valign="top">SolutionSizeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a57f9ae2e41909ab0aeb8ccabf99dc8ca">sample_clocal</a> (int connected_component_ID)</td></tr>
<tr class="memdesc:a57f9ae2e41909ab0aeb8ccabf99dc8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the connected component with the specified ID and samples a new sequence for the whole component.  <a href="classdesign_1_1DependencyGraph.html#a57f9ae2e41909ab0aeb8ccabf99dc8ca">More...</a><br /></td></tr>
<tr class="separator:a57f9ae2e41909ab0aeb8ccabf99dc8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392f54501162d8c0f806d3b7cd12ccbb"><td class="memItemLeft" align="right" valign="top">SolutionSizeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a392f54501162d8c0f806d3b7cd12ccbb">sample_clocal</a> ()</td></tr>
<tr class="memdesc:a392f54501162d8c0f806d3b7cd12ccbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a random connected component and samples a new sequence for the whole component.  <a href="classdesign_1_1DependencyGraph.html#a392f54501162d8c0f806d3b7cd12ccbb">More...</a><br /></td></tr>
<tr class="separator:a392f54501162d8c0f806d3b7cd12ccbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3323daeef3c83acb50d2caa5718401d5"><td class="memItemLeft" align="right" valign="top">SolutionSizeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a3323daeef3c83acb50d2caa5718401d5">number_of_sequences</a> ()</td></tr>
<tr class="memdesc:a3323daeef3c83acb50d2caa5718401d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of solutions given the dependency graph and sequence constraints.  <a href="classdesign_1_1DependencyGraph.html#a3323daeef3c83acb50d2caa5718401d5">More...</a><br /></td></tr>
<tr class="separator:a3323daeef3c83acb50d2caa5718401d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389349c595d7c39420b01de80a057c52"><td class="memItemLeft" align="right" valign="top">SolutionSizeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a389349c595d7c39420b01de80a057c52">number_of_sequences</a> (int connected_component_ID)</td></tr>
<tr class="memdesc:a389349c595d7c39420b01de80a057c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of solutions for the connected component with the given ID.  <a href="classdesign_1_1DependencyGraph.html#a389349c595d7c39420b01de80a057c52">More...</a><br /></td></tr>
<tr class="separator:a389349c595d7c39420b01de80a057c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac772c2237aa57eacdd89b76941c3cec0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#ac772c2237aa57eacdd89b76941c3cec0">number_of_connected_components</a> ()</td></tr>
<tr class="memdesc:ac772c2237aa57eacdd89b76941c3cec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of connected components into which the dependency graph was decomposed.  <a href="classdesign_1_1DependencyGraph.html#ac772c2237aa57eacdd89b76941c3cec0">More...</a><br /></td></tr>
<tr class="separator:ac772c2237aa57eacdd89b76941c3cec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554fd8328de551768cf43f421111b3bf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a554fd8328de551768cf43f421111b3bf">component_vertices</a> (int connected_component_ID)</td></tr>
<tr class="memdesc:a554fd8328de551768cf43f421111b3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with all the vertices in this component of the given ID.  <a href="classdesign_1_1DependencyGraph.html#a554fd8328de551768cf43f421111b3bf">More...</a><br /></td></tr>
<tr class="separator:a554fd8328de551768cf43f421111b3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb049a20268992a979a2264977dd4fff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#abb049a20268992a979a2264977dd4fff">articulation_vertices</a> ()</td></tr>
<tr class="memdesc:abb049a20268992a979a2264977dd4fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of vertices specified as articulation vertices.  <a href="classdesign_1_1DependencyGraph.html#abb049a20268992a979a2264977dd4fff">More...</a><br /></td></tr>
<tr class="separator:abb049a20268992a979a2264977dd4fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e3474fdd94a3530a8cdee33626704f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#ab5e3474fdd94a3530a8cdee33626704f">articulation_vertices</a> (int connected_component_ID)</td></tr>
<tr class="memdesc:ab5e3474fdd94a3530a8cdee33626704f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of vertices in the specified connected component specified as articulation vertices.  <a href="classdesign_1_1DependencyGraph.html#ab5e3474fdd94a3530a8cdee33626704f">More...</a><br /></td></tr>
<tr class="separator:ab5e3474fdd94a3530a8cdee33626704f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba37e2f77bc86add80141f337962f01a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#aba37e2f77bc86add80141f337962f01a">max_number_of_dimensions</a> ()</td></tr>
<tr class="memdesc:aba37e2f77bc86add80141f337962f01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal number of dimensions of all dynamic programming tables.  <a href="classdesign_1_1DependencyGraph.html#aba37e2f77bc86add80141f337962f01a">More...</a><br /></td></tr>
<tr class="separator:aba37e2f77bc86add80141f337962f01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0b2df58fa0e3363c78d15c0f5e2a00e9"><td class="memItemLeft" align="right" valign="top">detail::DependencyGraph&lt; R &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html#a0b2df58fa0e3363c78d15c0f5e2a00e9">g</a></td></tr>
<tr class="memdesc:a0b2df58fa0e3363c78d15c0f5e2a00e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the internal dependency graph object.  <a href="classdesign_1_1DependencyGraph.html#a0b2df58fa0e3363c78d15c0f5e2a00e9">More...</a><br /></td></tr>
<tr class="separator:a0b2df58fa0e3363c78d15c0f5e2a00e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename R&gt;<br />
class design::DependencyGraph&lt; R &gt;</h3>

<p>Dependency Graph which holds all structural constraints. </p>
<p>This graph is used to generate valid sequences compatible to the input structures </p>

<p class="definition">Definition at line <a class="el" href="RNAblueprint_8h_source.html#l00192">192</a> of file <a class="el" href="RNAblueprint_8h_source.html">RNAblueprint.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af293de4060b1fb0b36a2a6fa2e0688cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af293de4060b1fb0b36a2a6fa2e0688cc">&#9670;&nbsp;</a></span>DependencyGraph() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::<a class="el" href="classdesign_1_1DependencyGraph.html">DependencyGraph</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>structures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>rand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for the Dependency graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structures</td><td><b>vector</b> of <b>string</b> structures in dot-bracket notation. </td></tr>
    <tr><td class="paramname">constraints</td><td><b>string</b> containing the sequence constraints in IUPAC notation. Can also be a empty string! </td></tr>
    <tr><td class="paramname">rand</td><td>random number generator of your choice. Supported at the moment is only std::mt19937, but as it is templated, it can easily be extended to support more generators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if input is invalid or construction fails an exception is thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a250d599c82d2b41260583dd2d6a8fdf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250d599c82d2b41260583dd2d6a8fdf3">&#9670;&nbsp;</a></span>DependencyGraph() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::<a class="el" href="classdesign_1_1DependencyGraph.html">DependencyGraph</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>structures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for the Dependency graph using a predefined random number generator with the given seed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structures</td><td><b>vector</b> of <b>string</b> structures in dot-bracket notation. </td></tr>
    <tr><td class="paramname">constraints</td><td><b>string</b> containing the sequence constraints in IUPAC notation. Can also be a empty string! </td></tr>
    <tr><td class="paramname">seed</td><td><b>unsigned</b> long to be used as seed of the random number generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if input is invalid or construction fails an exception is thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8ee356ef0a9640cd3087818e5c28d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ee356ef0a9640cd3087818e5c28d16">&#9670;&nbsp;</a></span>DependencyGraph() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::<a class="el" href="classdesign_1_1DependencyGraph.html">DependencyGraph</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>structures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for the Dependency graph using a predefined random number generator with a clock generated seed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structures</td><td><b>vector</b> of <b>string</b> structures in dot-bracket notation. </td></tr>
    <tr><td class="paramname">constraints</td><td><b>string</b> containing the sequence constraints in IUPAC notation. Can also be a empty string! </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if input is invalid or construction fails an exception is thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa6ca86ea783a2b6311f391cfd193ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6ca86ea783a2b6311f391cfd193ad1">&#9670;&nbsp;</a></span>DependencyGraph() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::<a class="el" href="classdesign_1_1DependencyGraph.html">DependencyGraph</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>structures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>rand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for the Dependency graph without any sequence constraints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structures</td><td><b>vector</b> of <b>string</b> structures in dot-bracket notation. </td></tr>
    <tr><td class="paramname">rand</td><td>random number generator of your choice. Supported at the moment is only std::mt19937, but as it is templated, it can easily be extended to support more generators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if input is invalid or construction fails an exception is thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37f7113163d68de94cb8a3481c87d392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f7113163d68de94cb8a3481c87d392">&#9670;&nbsp;</a></span>DependencyGraph() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::<a class="el" href="classdesign_1_1DependencyGraph.html">DependencyGraph</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>structures</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for the Dependency graph using a predefined random number generator with a clock generated seed and an empty string as sequence constraints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structures</td><td><b>vector</b> of <b>string</b> structures in dot-bracket notation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if input is invalid or construction fails an exception is thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b4fad246b5719f03f2428946c8423db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4fad246b5719f03f2428946c8423db">&#9670;&nbsp;</a></span>DependencyGraph() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::<a class="el" href="classdesign_1_1DependencyGraph.html">DependencyGraph</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdesign_1_1DependencyGraph.html">DependencyGraph</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor which sets a new random seed in the copy sampled from the old generator. </p>

</div>
</div>
<a id="a550da1f6eebbe7881de860fc6dc76035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550da1f6eebbe7881de860fc6dc76035">&#9670;&nbsp;</a></span>~DependencyGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::~<a class="el" href="classdesign_1_1DependencyGraph.html">DependencyGraph</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor for the dependency graph object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abb049a20268992a979a2264977dd4fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb049a20268992a979a2264977dd4fff">&#9670;&nbsp;</a></span>articulation_vertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::articulation_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of vertices specified as articulation vertices. </p>
<p>These articulation vertices are also known as cut points or attachment points and also include cycle opening cuts.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdesign_1_1DependencyGraph.html#ab5e3474fdd94a3530a8cdee33626704f" title="Returns a list of vertices in the specified connected component specified as articulation vertices.">articulation_vertices(int connected_component_ID)</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>vector</b> of <b>integer</b> values specifying the positions/vertices marked as articulation vertices. </dd></dl>

</div>
</div>
<a id="ab5e3474fdd94a3530a8cdee33626704f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e3474fdd94a3530a8cdee33626704f">&#9670;&nbsp;</a></span>articulation_vertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::articulation_vertices </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>connected_component_ID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of vertices in the specified connected component specified as articulation vertices. </p>
<p>These articulation vertices include cut points, articulation points and also a cycle opening cuts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connected_component_ID</td><td><b>integer</b> specifying the connected component with its ID [ 0, <a class="el" href="classdesign_1_1DependencyGraph.html#ac772c2237aa57eacdd89b76941c3cec0" title="Returns the number of connected components into which the dependency graph was decomposed.">number_of_connected_components()</a> ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdesign_1_1DependencyGraph.html#ac772c2237aa57eacdd89b76941c3cec0" title="Returns the number of connected components into which the dependency graph was decomposed.">number_of_connected_components()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#abb049a20268992a979a2264977dd4fff" title="Returns a list of vertices specified as articulation vertices.">articulation_vertices()</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if connected_component_ID is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>vector</b> of <b>integer</b> values specifying the positions/vertices marked as articulation vertices in the connected component. </dd></dl>

</div>
</div>
<a id="a554fd8328de551768cf43f421111b3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554fd8328de551768cf43f421111b3bf">&#9670;&nbsp;</a></span>component_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::component_vertices </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>connected_component_ID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with all the vertices in this component of the given ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connected_component_ID</td><td><b>integer</b> specifying the connected component with its ID [ 0, <a class="el" href="classdesign_1_1DependencyGraph.html#ac772c2237aa57eacdd89b76941c3cec0" title="Returns the number of connected components into which the dependency graph was decomposed.">number_of_connected_components()</a> ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdesign_1_1DependencyGraph.html#ac772c2237aa57eacdd89b76941c3cec0" title="Returns the number of connected components into which the dependency graph was decomposed.">number_of_connected_components()</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if connected_component_ID is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>vector</b> of <b>integer</b> values specifying the positions/vertices contained in the connected component. </dd></dl>

</div>
</div>
<a id="ac0a3410de661dd384b7d170e5108ed0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a3410de661dd384b7d170e5108ed0c">&#9670;&nbsp;</a></span>get_graphml() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::get_graphml </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the root graph in GraphML format as a string. </p>
<p>Get the dependency graph in the XML based GraphML format for further analysis or visualization.</p>
<dl class="section return"><dt>Returns</dt><dd><b>string</b> containing the GraphML notation of the dependency graph. </dd></dl>

</div>
</div>
<a id="ad63f04ba5a78ad4199766966896e138f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63f04ba5a78ad4199766966896e138f">&#9670;&nbsp;</a></span>get_graphml() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::get_graphml </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>connected_component_ID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the connected component graph with the connected_component_ID in GraphML format as a string. </p>
<p>Get the graph for a specific connected component in the XML based GraphML format for further analysis or visualization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connected_component_ID</td><td><b>integer</b> specifying the connected component with its ID [ 0, <a class="el" href="classdesign_1_1DependencyGraph.html#ac772c2237aa57eacdd89b76941c3cec0" title="Returns the number of connected components into which the dependency graph was decomposed.">number_of_connected_components()</a> ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdesign_1_1DependencyGraph.html#ac772c2237aa57eacdd89b76941c3cec0" title="Returns the number of connected components into which the dependency graph was decomposed.">number_of_connected_components()</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if connected_component_ID is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>string</b> containing the GraphML notation of the connected component. </dd></dl>

</div>
</div>
<a id="a8ce7a6cc23ec087466079e4967d4380f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce7a6cc23ec087466079e4967d4380f">&#9670;&nbsp;</a></span>get_history()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::get_history </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the history of previous sampled sequences at this point. </p>
<dl class="section see"><dt>See also</dt><dd>set_history_size(int size), <a class="el" href="classdesign_1_1DependencyGraph.html#aca5c3c400f0008e440e49afa7da36567" title="Reverts the sequence to the previous one.">revert_sequence()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#ad199db489d2b88692f59e0eadfec74ee" title="Reverts the sequence to a previous one being (jump) steps in the history;.">revert_sequence(unsigned int jump)</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>vector</b> of <b>string</b> representing the history of previous sampled sequences. </dd></dl>

</div>
</div>
<a id="a214f172251f252e0b422e858f0ef1a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214f172251f252e0b422e858f0ef1a38">&#9670;&nbsp;</a></span>get_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::get_sequence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current RNA sequence as a string. </p>
<p>This sequence is only N directly after construction. You need to call either set or sample a initial sequence to avoid this behavior.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdesign_1_1DependencyGraph.html#a535101494526f22fdc7f049144fe962e" title="Resets all bases in the whole dependency graph and samples a new sequence randomly.">sample()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a0fdf0881f3bfaac53bdc8c0752d7b9f2" title="Allows you to set a initial sequence as starting point for your optimization.">set_sequence()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>string</b> representing the current RNA sequence. </dd></dl>

</div>
</div>
<a id="aba37e2f77bc86add80141f337962f01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba37e2f77bc86add80141f337962f01a">&#9670;&nbsp;</a></span>max_number_of_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::max_number_of_dimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximal number of dimensions of all dynamic programming tables. </p>
<p>This value is a great measure for the complexity of the graph coloring approach for the chosen input constraints.</p>
<dl class="section return"><dt>Returns</dt><dd><b>integer</b> specifying the maximal number of dimensions for all DP tables. </dd></dl>

</div>
</div>
<a id="ac772c2237aa57eacdd89b76941c3cec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac772c2237aa57eacdd89b76941c3cec0">&#9670;&nbsp;</a></span>number_of_connected_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::number_of_connected_components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of connected components into which the dependency graph was decomposed. </p>
<dl class="section return"><dt>Returns</dt><dd><b>integer</b> defining the number of connected components </dd></dl>

</div>
</div>
<a id="a3323daeef3c83acb50d2caa5718401d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3323daeef3c83acb50d2caa5718401d5">&#9670;&nbsp;</a></span>number_of_sequences() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SolutionSizeType <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::number_of_sequences </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of solutions given the dependency graph and sequence constraints. </p>
<p>Number of sequences is the total amount of sequences possible for the given structural and sequence constraints. This defines the size of the solution space.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdesign_1_1DependencyGraph.html#a389349c595d7c39420b01de80a057c52" title="Returns the amount of solutions for the connected component with the given ID.">number_of_sequences(int connected_component_ID)</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>number</b> of possible sequences for this design problem. </dd></dl>

</div>
</div>
<a id="a389349c595d7c39420b01de80a057c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389349c595d7c39420b01de80a057c52">&#9670;&nbsp;</a></span>number_of_sequences() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SolutionSizeType <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::number_of_sequences </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>connected_component_ID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of solutions for the connected component with the given ID. </p>
<p>Number of sequences is the total amount of sequences possible for the given connected component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connected_component_ID</td><td><b>integer</b> specifying the connected component with its ID [ 0, <a class="el" href="classdesign_1_1DependencyGraph.html#ac772c2237aa57eacdd89b76941c3cec0" title="Returns the number of connected components into which the dependency graph was decomposed.">number_of_connected_components()</a> ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdesign_1_1DependencyGraph.html#a3323daeef3c83acb50d2caa5718401d5" title="Returns the amount of solutions given the dependency graph and sequence constraints.">number_of_sequences()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#ac772c2237aa57eacdd89b76941c3cec0" title="Returns the number of connected components into which the dependency graph was decomposed.">number_of_connected_components()</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if connected_component_ID is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>number</b> of possible sequences for this connected component. </dd></dl>

</div>
</div>
<a id="aca5c3c400f0008e440e49afa7da36567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5c3c400f0008e440e49afa7da36567">&#9670;&nbsp;</a></span>revert_sequence() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::revert_sequence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverts the sequence to the previous one. </p>
<p>This sets the dependency graph to the previous sampled sequence state.</p>
<dl class="section see"><dt>See also</dt><dd>set_history_size(int size), <a class="el" href="classdesign_1_1DependencyGraph.html#ad199db489d2b88692f59e0eadfec74ee" title="Reverts the sequence to a previous one being (jump) steps in the history;.">revert_sequence(unsigned int jump)</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>boolean</b> specifying if this move was possible. If no previous sequence is stored, it returns false. </dd></dl>

</div>
</div>
<a id="ad199db489d2b88692f59e0eadfec74ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad199db489d2b88692f59e0eadfec74ee">&#9670;&nbsp;</a></span>revert_sequence() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::revert_sequence </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>jump</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverts the sequence to a previous one being (jump) steps in the history;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jump</td><td><b>integer</b> specifying the length of the time-jump. 2 would for example revert the sequence to the one before the previous one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>set_history_size(int size), <a class="el" href="classdesign_1_1DependencyGraph.html#aca5c3c400f0008e440e49afa7da36567" title="Reverts the sequence to the previous one.">revert_sequence()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>boolean</b> specifying if this move was possible. If no such previous sequence is stored, it returns false. </dd></dl>

</div>
</div>
<a id="a535101494526f22fdc7f049144fe962e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535101494526f22fdc7f049144fe962e">&#9670;&nbsp;</a></span>sample() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SolutionSizeType <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::sample </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets all bases in the whole dependency graph and samples a new sequence randomly. </p>
<p>Call <a class="el" href="classdesign_1_1DependencyGraph.html#a214f172251f252e0b422e858f0ef1a38" title="Get the current RNA sequence as a string.">get_sequence()</a> after you sampled a new sequence. It is not possible to retrieve the previous sequence with this move.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdesign_1_1DependencyGraph.html#a214f172251f252e0b422e858f0ef1a38" title="Get the current RNA sequence as a string.">get_sequence()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a4f8203aff1c75840df6ccabb1e08d4c8" title="Resets and samples only the smallest subgraph(s) possible containing the vertex at the given position...">sample(int position)</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a0fd1274742cce748ff01abcf96d9b8e4" title="Resets only the smallest subgraph(s) possible containing the vertices from position start to end.">sample(int start, int end)</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>number</b> of possible solutions for this sampling (number of all possible sequences minus the current one). </dd></dl>

</div>
</div>
<a id="a4f8203aff1c75840df6ccabb1e08d4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8203aff1c75840df6ccabb1e08d4c8">&#9670;&nbsp;</a></span>sample() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SolutionSizeType <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::sample </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets and samples only the smallest subgraph(s) possible containing the vertex at the given position in the sequence. </p>
<p>This way you can optimize by targeted sampling at the given positions. All positions dependent on the chosen one will also be sampled. If your position is a articulation vertex, the whole connected component will be re-sampled. Else, in case of being a non-articulation vertex, only the smallest path containing the vertex will be sampled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td><b>integer</b> specifying the position to re-sample [ 0, N ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdesign_1_1DependencyGraph.html#a214f172251f252e0b422e858f0ef1a38" title="Get the current RNA sequence as a string.">get_sequence()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a535101494526f22fdc7f049144fe962e" title="Resets all bases in the whole dependency graph and samples a new sequence randomly.">sample()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a0fd1274742cce748ff01abcf96d9b8e4" title="Resets only the smallest subgraph(s) possible containing the vertices from position start to end.">sample(int start, int end)</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>number</b> of possible solutions for this sampling. </dd></dl>

</div>
</div>
<a id="a0fd1274742cce748ff01abcf96d9b8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd1274742cce748ff01abcf96d9b8e4">&#9670;&nbsp;</a></span>sample() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SolutionSizeType <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::sample </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets only the smallest subgraph(s) possible containing the vertices from position start to end. </p>
<p>This way you can optimize by targeted sampling at the given positions. All positions dependent on the chosen ones will also be sampled. If your positions contain articulation vertices, the whole connected components will be re-sampled. Else, in case of being only non-articulation vertex, only the smallest paths containing the vertices will be sampled. Positions for start and end are inclusive [ start, end ]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td><b>integer</b> specifying the first position to re-sample [ 0, N ) </td></tr>
    <tr><td class="paramname">end</td><td><b>integer</b> specifying the last position to re-sample [ 0, N ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdesign_1_1DependencyGraph.html#a214f172251f252e0b422e858f0ef1a38" title="Get the current RNA sequence as a string.">get_sequence()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a535101494526f22fdc7f049144fe962e" title="Resets all bases in the whole dependency graph and samples a new sequence randomly.">sample()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a4f8203aff1c75840df6ccabb1e08d4c8" title="Resets and samples only the smallest subgraph(s) possible containing the vertex at the given position...">sample(int position)</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>number</b> of possible solutions for this sampling. </dd></dl>

</div>
</div>
<a id="a392f54501162d8c0f806d3b7cd12ccbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392f54501162d8c0f806d3b7cd12ccbb">&#9670;&nbsp;</a></span>sample_clocal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SolutionSizeType <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::sample_clocal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a random connected component and samples a new sequence for the whole component. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdesign_1_1DependencyGraph.html#ae147bb714306f05740a54d9970615ffa" title="Randomly chooses one path (either top-level a connected component, or within a block,...">sample_plocal()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#afa17cde3896055c4e162a2e0864a11f2" title="Randomly chooses one path (either top-level a connected component, or within a block,...">sample_plocal(int min_num_pos, int max_num_pos)</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a57f9ae2e41909ab0aeb8ccabf99dc8ca" title="Takes the connected component with the specified ID and samples a new sequence for the whole componen...">sample_clocal(int connected_component_ID)</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a25c6f862884b192aec61394826359162" title="Randomly chooses a connected component with the given size and samples a new sequence for the whole c...">sample_clocal(int min_num_pos, int max_num_pos)</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>number</b> of possible sequences for this sampling. </dd></dl>

</div>
</div>
<a id="a57f9ae2e41909ab0aeb8ccabf99dc8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f9ae2e41909ab0aeb8ccabf99dc8ca">&#9670;&nbsp;</a></span>sample_clocal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SolutionSizeType <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::sample_clocal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>connected_component_ID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes the connected component with the specified ID and samples a new sequence for the whole component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connected_component_ID</td><td><b>integer</b> specifying the connected component with its ID [ 0, <a class="el" href="classdesign_1_1DependencyGraph.html#ac772c2237aa57eacdd89b76941c3cec0" title="Returns the number of connected components into which the dependency graph was decomposed.">number_of_connected_components()</a> ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdesign_1_1DependencyGraph.html#ac772c2237aa57eacdd89b76941c3cec0" title="Returns the number of connected components into which the dependency graph was decomposed.">number_of_connected_components()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#ae147bb714306f05740a54d9970615ffa" title="Randomly chooses one path (either top-level a connected component, or within a block,...">sample_plocal()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#afa17cde3896055c4e162a2e0864a11f2" title="Randomly chooses one path (either top-level a connected component, or within a block,...">sample_plocal(int min_num_pos, int max_num_pos)</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a392f54501162d8c0f806d3b7cd12ccbb" title="Takes a random connected component and samples a new sequence for the whole component.">sample_clocal()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a25c6f862884b192aec61394826359162" title="Randomly chooses a connected component with the given size and samples a new sequence for the whole c...">sample_clocal(int min_num_pos, int max_num_pos)</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if connected_component_ID is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>number</b> of possible sequences for this sampling. </dd></dl>

</div>
</div>
<a id="a25c6f862884b192aec61394826359162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c6f862884b192aec61394826359162">&#9670;&nbsp;</a></span>sample_clocal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SolutionSizeType <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::sample_clocal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_num_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_num_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomly chooses a connected component with the given size and samples a new sequence for the whole component. </p>
<p>This is a more global way of sampling a new sequence as it exchanges a much bigger graph object. min_num_pos, max_num_pos set the minimal/maximal number of sampled positions, e.g., for [ 3, 5 ] only connected components with minimal 3 and maximal 5 vertices will be chosen for sampling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_num_pos</td><td><b>integer</b> specifying the minimal size of the component to re-sample [ 1, N ) </td></tr>
    <tr><td class="paramname">max_num_pos</td><td><b>integer</b> specifying the maximal size of the component to re-sample [ 1, N ). 0 defines infinity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdesign_1_1DependencyGraph.html#ae147bb714306f05740a54d9970615ffa" title="Randomly chooses one path (either top-level a connected component, or within a block,...">sample_plocal()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#afa17cde3896055c4e162a2e0864a11f2" title="Randomly chooses one path (either top-level a connected component, or within a block,...">sample_plocal(int min_num_pos, int max_num_pos)</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a392f54501162d8c0f806d3b7cd12ccbb" title="Takes a random connected component and samples a new sequence for the whole component.">sample_clocal()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a57f9ae2e41909ab0aeb8ccabf99dc8ca" title="Takes the connected component with the specified ID and samples a new sequence for the whole componen...">sample_clocal(int connected_component_ID)</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>number</b> of possible solutions for this sampling. </dd></dl>

</div>
</div>
<a id="ae147bb714306f05740a54d9970615ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae147bb714306f05740a54d9970615ffa">&#9670;&nbsp;</a></span>sample_plocal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SolutionSizeType <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::sample_plocal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomly chooses one path (either top-level a connected component, or within a block, etc.) and samples all positions. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdesign_1_1DependencyGraph.html#afa17cde3896055c4e162a2e0864a11f2" title="Randomly chooses one path (either top-level a connected component, or within a block,...">sample_plocal(int min_num_pos, int max_num_pos)</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a392f54501162d8c0f806d3b7cd12ccbb" title="Takes a random connected component and samples a new sequence for the whole component.">sample_clocal()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a25c6f862884b192aec61394826359162" title="Randomly chooses a connected component with the given size and samples a new sequence for the whole c...">sample_clocal(int min_num_pos, int max_num_pos)</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a57f9ae2e41909ab0aeb8ccabf99dc8ca" title="Takes the connected component with the specified ID and samples a new sequence for the whole componen...">sample_clocal(int connected_component_ID)</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>number</b> of possible solutions for this sampling. </dd></dl>

</div>
</div>
<a id="afa17cde3896055c4e162a2e0864a11f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa17cde3896055c4e162a2e0864a11f2">&#9670;&nbsp;</a></span>sample_plocal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SolutionSizeType <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::sample_plocal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_num_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_num_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomly chooses one path (either top-level a connected component, or within a block, etc.) with the given size and samples all positions. </p>
<p>Articulation vertices such as cut points or articulation points will stay the same. Therefore it is guaranteed that the sampling is correct, even if we only sample a small local piece of a more complex graph object. min_num_pos and max_num_pos set the minimal/maximal number of sampled positions, e.g., for [ 3, 5 ] only paths with minimal 3 and maximal 5 non-articulation vertices will be chosen for sampling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_num_pos</td><td><b>integer</b> specifying the minimal size of the component to re-sample [ 1, N ) </td></tr>
    <tr><td class="paramname">max_num_pos</td><td><b>integer</b> specifying the maximal size of the component to re-sample [ 1, N ). 0 defines infinity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdesign_1_1DependencyGraph.html#ae147bb714306f05740a54d9970615ffa" title="Randomly chooses one path (either top-level a connected component, or within a block,...">sample_plocal()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a392f54501162d8c0f806d3b7cd12ccbb" title="Takes a random connected component and samples a new sequence for the whole component.">sample_clocal()</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a25c6f862884b192aec61394826359162" title="Randomly chooses a connected component with the given size and samples a new sequence for the whole c...">sample_clocal(int min_num_pos, int max_num_pos)</a>, <a class="el" href="classdesign_1_1DependencyGraph.html#a57f9ae2e41909ab0aeb8ccabf99dc8ca" title="Takes the connected component with the specified ID and samples a new sequence for the whole componen...">sample_clocal(int connected_component_ID)</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>number</b> of possible solutions for this sampling. </dd></dl>

</div>
</div>
<a id="a911ddbc7d43c66a43c145dee29ca6c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911ddbc7d43c66a43c145dee29ca6c20">&#9670;&nbsp;</a></span>set_history_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::set_history_size </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum number of previous sampled sequences to memorize (Default: 100). </p>
<p>A history of all sampled sequences is stored within the dependency graph object. Use this function to set the size of the storage stack (Minimum: 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td><b>integer</b> to set the size (&gt;0) of the history storage container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fdf0881f3bfaac53bdc8c0752d7b9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdf0881f3bfaac53bdc8c0752d7b9f2">&#9670;&nbsp;</a></span>set_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SolutionSizeType <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::set_sequence </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows you to set a initial sequence as starting point for your optimization. </p>
<p>Only real bases are allowed and the sequence has to fulfill all structural constraints, otherwise an error is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td><b>string</b> containing the sequence constraints in IUPAC notation. Only [AUGC] are allowed as bases. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if input string contains invalid characters or constraints cannot be fulfilled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>number</b> of possible solutions for this sampling. Is 1 all the time for <a class="el" href="classdesign_1_1DependencyGraph.html#a0fdf0881f3bfaac53bdc8c0752d7b9f2" title="Allows you to set a initial sequence as starting point for your optimization.">set_sequence()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a0b2df58fa0e3363c78d15c0f5e2a00e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2df58fa0e3363c78d15c0f5e2a00e9">&#9670;&nbsp;</a></span>g</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::DependencyGraph&lt;R&gt;* <a class="el" href="classdesign_1_1DependencyGraph.html">design::DependencyGraph</a>&lt; R &gt;::g</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the internal dependency graph object. </p>

<p class="definition">Definition at line <a class="el" href="RNAblueprint_8h_source.html#l00448">448</a> of file <a class="el" href="RNAblueprint_8h_source.html">RNAblueprint.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lib/<a class="el" href="RNAblueprint_8h_source.html">RNAblueprint.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedesign.html">design</a></li><li class="navelem"><a class="el" href="classdesign_1_1DependencyGraph.html">DependencyGraph</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
