<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RNAblueprint-1.3.2: design Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rnablueprint-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RNAblueprint-1.3.2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacedesign.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">design Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>All classes and functions for the RNA design library are under the design namespace.  
<a href="namespacedesign.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdesign_1_1DependencyGraph.html">DependencyGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dependency Graph which holds all structural constraints.  <a href="classdesign_1_1DependencyGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8fc0aec08efdb4455d2a7e1f620bf265"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedesign.html#a8fc0aec08efdb4455d2a7e1f620bf265">initialize_library</a> (bool debug)</td></tr>
<tr class="memdesc:a8fc0aec08efdb4455d2a7e1f620bf265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Libraries global variables.  <a href="namespacedesign.html#a8fc0aec08efdb4455d2a7e1f620bf265">More...</a><br /></td></tr>
<tr class="separator:a8fc0aec08efdb4455d2a7e1f620bf265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d8b9638e7e2464fc2edc7f1b706cbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedesign.html#ae1d8b9638e7e2464fc2edc7f1b706cbe">initialize_library</a> (bool debug, int construction_timeout)</td></tr>
<tr class="memdesc:ae1d8b9638e7e2464fc2edc7f1b706cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Libraries global variables.  <a href="namespacedesign.html#ae1d8b9638e7e2464fc2edc7f1b706cbe">More...</a><br /></td></tr>
<tr class="separator:ae1d8b9638e7e2464fc2edc7f1b706cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e51a64b79205f5c413cae3292912d6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedesign.html#af3e51a64b79205f5c413cae3292912d6">structures_to_graphml</a> (std::vector&lt; std::string &gt; structures, std::string constraints, bool decompose, unsigned long seed)</td></tr>
<tr class="memdesc:af3e51a64b79205f5c413cae3292912d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a graphml representation of structural and sequence constraints.  <a href="namespacedesign.html#af3e51a64b79205f5c413cae3292912d6">More...</a><br /></td></tr>
<tr class="separator:af3e51a64b79205f5c413cae3292912d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5450a8bae9c437677a80bed71c95cdb9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedesign.html#a5450a8bae9c437677a80bed71c95cdb9">structures_to_graphml</a> (std::vector&lt; std::string &gt; structures, std::string constraints, bool decompose)</td></tr>
<tr class="memdesc:a5450a8bae9c437677a80bed71c95cdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a graphml representation of structural and sequence constraints.  <a href="namespacedesign.html#a5450a8bae9c437677a80bed71c95cdb9">More...</a><br /></td></tr>
<tr class="separator:a5450a8bae9c437677a80bed71c95cdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fce75eddf08ea96fd3f59a70a88b4d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedesign.html#a17fce75eddf08ea96fd3f59a70a88b4d">structures_to_graphml</a> (std::vector&lt; std::string &gt; structures, std::string constraints)</td></tr>
<tr class="memdesc:a17fce75eddf08ea96fd3f59a70a88b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a graphml representation of structural and sequence constraints.  <a href="namespacedesign.html#a17fce75eddf08ea96fd3f59a70a88b4d">More...</a><br /></td></tr>
<tr class="separator:a17fce75eddf08ea96fd3f59a70a88b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cad79644669673b0bbb917b4f72129"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedesign.html#a07cad79644669673b0bbb917b4f72129">graph_is_bipartite</a> (std::vector&lt; std::string &gt; structures)</td></tr>
<tr class="memdesc:a07cad79644669673b0bbb917b4f72129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the dependency graph built from the given input structures is bipartite.  <a href="namespacedesign.html#a07cad79644669673b0bbb917b4f72129">More...</a><br /></td></tr>
<tr class="separator:a07cad79644669673b0bbb917b4f72129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ddc0596f71522e14e97ff2ce4530a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedesign.html#ad2ddc0596f71522e14e97ff2ce4530a8">sequence_structure_compatible</a> (std::string sequence, std::vector&lt; std::string &gt; structures)</td></tr>
<tr class="memdesc:ad2ddc0596f71522e14e97ff2ce4530a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the the given sequence is compatible to all the given structures.  <a href="namespacedesign.html#ad2ddc0596f71522e14e97ff2ce4530a8">More...</a><br /></td></tr>
<tr class="separator:ad2ddc0596f71522e14e97ff2ce4530a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e110e07eda2fa4ec637c1da57046a4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedesign.html#ad3e110e07eda2fa4ec637c1da57046a4">incompatible_sequence_positions</a> (std::string sequence, std::string structure)</td></tr>
<tr class="memdesc:ad3e110e07eda2fa4ec637c1da57046a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the the given sequence is compatible to all the given structures.  <a href="namespacedesign.html#ad3e110e07eda2fa4ec637c1da57046a4">More...</a><br /></td></tr>
<tr class="separator:ad3e110e07eda2fa4ec637c1da57046a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>All classes and functions for the RNA design library are under the design namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a07cad79644669673b0bbb917b4f72129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cad79644669673b0bbb917b4f72129">&#9670;&nbsp;</a></span>graph_is_bipartite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool design::graph_is_bipartite </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>structures</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the dependency graph built from the given input structures is bipartite. </p>
<p>This helper function checks, if a set of input structures will generate a bipartite dependency graph. If the graph is not bipartite, it cannot be used to generate a valid RNA sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structures</td><td><b>vector</b> of <b>string</b> structures in dot-bracket notation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if input is invalid or construction fails an exception is thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>boolean</b> specifying whether the input structures can be constructed to a bipartite dependency graph. </dd></dl>

</div>
</div>
<a id="ad3e110e07eda2fa4ec637c1da57046a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e110e07eda2fa4ec637c1da57046a4">&#9670;&nbsp;</a></span>incompatible_sequence_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; design::incompatible_sequence_positions </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>structure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the the given sequence is compatible to all the given structures. </p>
<p>This function checks, if a given sequence can fold into the given structure and returns an empty vector if this is the case. Else, it returns all positions on the sequence which are incompatible with the given structural constraint. E.g. incompatible_sequence_positions("ANC", "(.)") would return [0, 2]!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td><b>string</b> in IUPAC notation. </td></tr>
    <tr><td class="paramname">structure</td><td><b>string</b> in dot-bracket notation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if input is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>map</b> of a pair of <b>integers</b> specifying the sequence positions incompatible to the structure input. </dd></dl>

</div>
</div>
<a id="a8fc0aec08efdb4455d2a7e1f620bf265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc0aec08efdb4455d2a7e1f620bf265">&#9670;&nbsp;</a></span>initialize_library() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void design::initialize_library </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Libraries global variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">debug</td><td><b>boolean</b> whether to print debugging information to std:err (default: false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1d8b9638e7e2464fc2edc7f1b706cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d8b9638e7e2464fc2edc7f1b706cbe">&#9670;&nbsp;</a></span>initialize_library() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void design::initialize_library </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>construction_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Libraries global variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">debug</td><td><b>boolean</b> whether to print debugging information to std:err (default: false) </td></tr>
    <tr><td class="paramname">construction_timeout</td><td><b>integer</b> specifying the dependency graph construction timeout in seconds. 0 is infinite. (default: 0) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2ddc0596f71522e14e97ff2ce4530a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ddc0596f71522e14e97ff2ce4530a8">&#9670;&nbsp;</a></span>sequence_structure_compatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool design::sequence_structure_compatible </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>structures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the the given sequence is compatible to all the given structures. </p>
<p>This function checks, if a given sequence can form all base-pairs given by a set of input structures. Or the other way around, if the given structures could have produced this sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td><b>string</b> in IUPAC notation. </td></tr>
    <tr><td class="paramname">structures</td><td><b>vector</b> of <b>string</b> structures in dot-bracket notation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if input is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>boolean</b> specifying whether the input sequence is compatible to all the given structures. </dd></dl>

</div>
</div>
<a id="a17fce75eddf08ea96fd3f59a70a88b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17fce75eddf08ea96fd3f59a70a88b4d">&#9670;&nbsp;</a></span>structures_to_graphml() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string design::structures_to_graphml </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>structures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a graphml representation of structural and sequence constraints. </p>
<p>This function generates a graphml representation of the dependency graph given some structural and sequence constraints without constructing a <a class="el" href="classdesign_1_1DependencyGraph.html" title="Dependency Graph which holds all structural constraints.">DependencyGraph</a> object, but with decomposition of the graph into subpaths. It is mainly thought to be useful for developmental purposes, analysis of hard problems and vizualisation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structures</td><td><b>vector</b> of <b>string</b> structures in dot-bracket notation. </td></tr>
    <tr><td class="paramname">constraints</td><td><b>string</b> containing the sequence constraints in IUPAC notation. Can also be a empty string! </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if input is invalid or construction/decomposition fails an exception is thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>string</b> containing the GraphML notation of the dependency graph. </dd></dl>

</div>
</div>
<a id="a5450a8bae9c437677a80bed71c95cdb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5450a8bae9c437677a80bed71c95cdb9">&#9670;&nbsp;</a></span>structures_to_graphml() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string design::structures_to_graphml </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>structures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>decompose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a graphml representation of structural and sequence constraints. </p>
<p>This function generates a graphml representation of the dependency graph given some structural and sequence constraints without constructing a <a class="el" href="classdesign_1_1DependencyGraph.html" title="Dependency Graph which holds all structural constraints.">DependencyGraph</a> object, with or without decomposition of the graph into subpaths. It is mainly thought to be useful for developmental purposes, analysis of hard problems and vizualisation. Caution: There are random parts in the decomposition algorithms. If you want to assign a seed, use <a class="el" href="namespacedesign.html#af3e51a64b79205f5c413cae3292912d6" title="Generate a graphml representation of structural and sequence constraints.">structures_to_graphml(std::vector&lt;std::string&gt; structures, std::string constraints, bool decompose, unsigned long seed)</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structures</td><td><b>vector</b> of <b>string</b> structures in dot-bracket notation. </td></tr>
    <tr><td class="paramname">constraints</td><td><b>string</b> containing the sequence constraints in IUPAC notation. Can also be a empty string! </td></tr>
    <tr><td class="paramname">decompose</td><td><b>boolean</b> Whether to decompose the dependency graph into paths and therefore draw articulation vertices and ears. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if input is invalid or construction/decomposition fails an exception is thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>string</b> containing the GraphML notation of the dependency graph. </dd></dl>

</div>
</div>
<a id="af3e51a64b79205f5c413cae3292912d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e51a64b79205f5c413cae3292912d6">&#9670;&nbsp;</a></span>structures_to_graphml() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string design::structures_to_graphml </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>structures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>decompose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a graphml representation of structural and sequence constraints. </p>
<p>This function generates a graphml representation of the dependency graph given some structural and sequence constraints without constructing a <a class="el" href="classdesign_1_1DependencyGraph.html" title="Dependency Graph which holds all structural constraints.">DependencyGraph</a> object, with or without decomposition of the graph into subpaths. It is mainly thought to be useful for developmental purposes, analysis of hard problems and vizualisation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structures</td><td><b>vector</b> of <b>string</b> structures in dot-bracket notation. </td></tr>
    <tr><td class="paramname">constraints</td><td><b>string</b> containing the sequence constraints in IUPAC notation. Can also be a empty string! </td></tr>
    <tr><td class="paramname">decompose</td><td><b>boolean</b> Whether to decompose the dependency graph into paths and therefore draw articulation vertices and ears. </td></tr>
    <tr><td class="paramname">seed</td><td><b>unsigned</b> long Seed for the random number generator which is used for some random parts of the decomposition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if input is invalid or construction/decomposition fails an exception is thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>string</b> containing the GraphML notation of the dependency graph. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedesign.html">design</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
